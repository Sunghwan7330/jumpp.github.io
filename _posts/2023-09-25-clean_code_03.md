---
title: "2장 함수"
excerpt: "클린코드 3장 내용에 대한 요약입니다."

categories:
  - 'cleancode'
tags:
  - cleancode

date: 2023-09-25
last_modified_at: 2023-09-25
---

### 개요

- 아래의 두 코드를 비교해 볼 것
    
    ```java
    // 리펙터링 전
    public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
      WikiPage wikiPage = pageData.getWikiPage();
      StringBuffer buffer = new StringBuffer();
    
      if (pageData.hasAttribute("Test")) {
        if (includeSuiteSetup) {
          WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
          if (suiteSetup != null) {
            WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
            String pagePathName = PathParser.render(pagePath);
            buffer.append("!include -setup .")
              .append(pagePathName)
              .append("\n");
          }
        }
        WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
        if (setup != null) {
          WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
          String setupPathName = PathParser.render(setupPath);
          buffer.append("!include -setup .")
            .append(setupPathName)
            .append("\n");
        }
      }
      buffer.append(pageData.getContent());
      if (pageData.hasAttribute("Test")) {
        WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
        if (teardown != null) {
          WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);
          String tearDownPathName = PathParser.render(tearDownPath);
          buffer.append("\n")
            .append("!include -teardown .")
            .append(tearDownPathName)
            .append("\n");
        }
        if (includeSuiteSetup) {
          WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_TEARDOWN_NAME, wikiPage);
          if (suiteTeardown != null) {
            WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath (suiteTeardown);
            String pagePathName = PathParser.render(pagePath);
            buffer.append("!include -teardown .")
              .append(pagePathName)
              .append("\n");
          }
        }
      }
      pageData.setContent(buffer.toString());
      return pageData.getHtml();
    }
    ```
    
    ```java
    // 리펙터링 후
    public static String renderPageWithSetupsAndTeardowns(PageData pageData, boolean isSuite) throws Exception {
      boolean isTestPage = pageData.hasAttribute("Test");
      if (isTestPage) {
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
      }
      return pageData.getHtml();
    }
    ```
    
- 리펙터링한 코드는 코드를 이해하기 쉬워짐


### 작게 만들어라

- 함수는 작으면 작을수록 좋음 (저자의 경험에 바탕)
- 들여쓰기는 2단을 넘지 말 것

### 한가지만 해라!

- 개요에서 제시한 리팩터링 전 코드는 한 함수에서 여러가지 역할을 수행함
  - 버퍼 생성, 페이지 로드, 페이지 검색, 경로 랜더링 등등….
- 함수는 한가지만 수행하고, 그 한가지만을 잘 해야함

### 함수 당 추상화 수준은 하나로!

- 함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 함
- 내려가기 규칙
  - 코드는 위에서 아래로 이야기처럼 읽혀야 좋음
  - 한 함수의 다음에는 추상화 수준이 한 단계 낮은 함수가 옴
  - 즉, 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한번에 한 단계씩 낮아짐

### switch 문

- Switch 문은 작게 만들기 어렵고, 한 가지 작업만 하는 switch 문을 만들기도 어려
- Switch 문을 완전히 피할 수는 없지만, 저차원 클래스에 숨기는 방법이 있음
      
  ```java
  public Money calculatePay(Employee e) throws InvalidEmployeeType {
    switch (e.type) {
      case COMMISSIONED:
        return calculateCommissionedPay(e);
      case HOURLY:
        return calculateHourlyPay(e);
      case SALARIED:
        return calculateSalariedPay(e);
      default:
        throw new InvalidEmployeeType(e.type);
    }
  }
  ```
    
- 위 함수의 문제점
  - 함수가 길다. 새 직원 유형이 추가되면 더 길어짐
  - 한가지 작업만 수행하지 않음
  - SRP(Single Responsibility Principle)를 위반함
  - OCP(Open Closed Principle)를 위반함.  새 직원 유형을 추가할 때 마다 코드를 변경하기 때문
- 이 문제를 해결한 코드
  - Switch 문은 추상 팩토리에 숨김
  - 팩토리는 Switch 문을 사용해 적절한 `Empolyee` 파생 클래스의 인스턴스를 생성

```java
public abstract class Employee {
  public abstract boolean isPayday();
  public abstract Money calculatePay();
  public abstract void deliverPay(Money pay);
}
-----------------
public interface EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
-----------------
public class EmployeeFactoryImpl implements EmployeeFactory {
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType {
    switch (r.type) {
      case COMMISSIONED:
        return new CommissionedEmployee(r) ;
      case HOURLY:
        return new HourlyEmployee(r);
      case SALARIED:
        return new SalariedEmployee(r);
      default:
        throw new InvalidEmployeeType(r.type);
    }
  }
}
```

### 서술적인 이름을 사용하라!

- 함수가 작고 단순할 수록 서술적인 이름을 고르기 쉬워짐
- 이름이 길더라도 서술적인게 긴 주석보다 좋음
- 서술적인 이름을 사용하면 설계가 뚜렷해지므로 코드를 개선하기 쉬워짐
- 모듈 내에서 함수 이름은 같은 문구, 명사, 동사 사용이 좋음
