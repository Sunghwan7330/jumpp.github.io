---
title: "[C코드 최적화] 집합원소 저장의 효율적 방법"
excerpt: "해당 내용은 '임베디드 프로그래밍 C코드 최적화' 책의 story 18에 내용을 정리하였습니다. "

categories:
  - 'embedded_c_optimization'
tags:
  - c코드 최적화
  - 북스터디
  - 최적화
  - 루프최적화
  - for문

toc: true
toc_sticky: true

date: 2021-06-20
last_modified_at: 2021-06-21
---

# 개요 

해당 내용은 '임베디드 프로그래밍 C코드 최적화' 책의 story 18에 내용을 정리하였습니다.

최적화에 필요한 다양한 방법을 알아보려 합니다. 

어려운 내용은 없으나, 습관을 들이는게 중요할듯 합니다. 

# 비용이 낮은 연산자 선택하기 

같은 결과를 만들 수 있다면 비용이 낮은 연산자를 선택하여 코딩하는 것이 좋습니다. (근데 이게 참....어려움 ㅠㅠ)

예를 들어 나눗셈에 `/` 나 `%` 연산자를 쉽게 사용하지만, 이 연산자의 비용은 매우 큽니다. 

좀 더 좋은 알고리즘을 고민하고, 한 라인을 코딩하더라도 어러 표현방법, 여러 연산자를 고민하는 것이 좋습니다. 

```c
#include <stdio.h>

void main(){
  int x, y, z, k;
  x = z = 10, y = k = 50;
  y %= 12; // y와 k는 모두 12로 나눈 나머지 값을 갖는다
  k &= 3;
  x /= 8; // x와 Z는 모두 8로 나눈 몫을 값으로 갖는다.
  z >>= 3;
  printf("x=%d, z=%d, y=%d, k=%d \n", x, z, y, k);
}
```

objdump를 이용해 어셈블리를 확인해보면 다음과 같습니다. 
```
void main(){
   10408:       e92d4800        push    {fp, lr}
   1040c:       e28db004        add     fp, sp, #4
   10410:       e24dd018        sub     sp, sp, #24
  int x, y, z, k;
  x = z = 10, y = k = 50;
   10414:       e3a0300a        mov     r3, #10
   10418:       e50b3008        str     r3, [fp, #-8]
   1041c:       e51b3008        ldr     r3, [fp, #-8]
   10420:       e50b300c        str     r3, [fp, #-12]
   10424:       e3a03032        mov     r3, #50 ; 0x32
   10428:       e50b3010        str     r3, [fp, #-16]
   1042c:       e51b3010        ldr     r3, [fp, #-16]
   10430:       e50b3014        str     r3, [fp, #-20]  ; 0xffffffec
  y %= 12; // y와 k는 모두 12로 나눈 나머지 값을 갖는다
   10434:       e51b2014        ldr     r2, [fp, #-20]  ; 0xffffffec
   10438:       e59f3080        ldr     r3, [pc, #128]  ; 104c0 <main+0xb8>
   1043c:       e0c31293        smull   r1, r3, r3, r2
   10440:       e1a010c3        asr     r1, r3, #1
   10444:       e1a03fc2        asr     r3, r2, #31
   10448:       e0411003        sub     r1, r1, r3
   1044c:       e1a03001        mov     r3, r1
   10450:       e1a03083        lsl     r3, r3, #1
   10454:       e0833001        add     r3, r3, r1
   10458:       e1a03103        lsl     r3, r3, #2
   1045c:       e0423003        sub     r3, r2, r3
   10460:       e50b3014        str     r3, [fp, #-20]  ; 0xffffffec
  k &= 3;
   10464:       e51b3010        ldr     r3, [fp, #-16]
   10468:       e2033003        and     r3, r3, #3
   1046c:       e50b3010        str     r3, [fp, #-16]
  x /= 8; // x와 Z는 모두 8로 나눈 몫을 값으로 갖는다.
   10470:       e51b300c        ldr     r3, [fp, #-12]
   10474:       e2832007        add     r2, r3, #7
   10478:       e3530000        cmp     r3, #0
   1047c:       b1a03002        movlt   r3, r2
   10480:       a1a03003        movge   r3, r3
   10484:       e1a031c3        asr     r3, r3, #3
   10488:       e50b300c        str     r3, [fp, #-12]
  z >>= 3;
   1048c:       e51b3008        ldr     r3, [fp, #-8]
   10490:       e1a031c3        asr     r3, r3, #3
   10494:       e50b3008        str     r3, [fp, #-8]
  printf("x=%d, z=%d, y=%d, k=%d \n", x, z, y, k);
   10498:       e51b3010        ldr     r3, [fp, #-16]
   1049c:       e58d3000        str     r3, [sp]
   104a0:       e51b3014        ldr     r3, [fp, #-20]  ; 0xffffffec
   104a4:       e51b2008        ldr     r2, [fp, #-8]
   104a8:       e51b100c        ldr     r1, [fp, #-12]
   104ac:       e59f0010        ldr     r0, [pc, #16]   ; 104c4 <main+0xbc>
   104b0:       ebffff8c        bl      102e8 <printf@plt>
}
```

위의 예제를 볼때 연산자의 차이가 꽤 많이 나는것을 알 수 있습니다. 
비트 연산은 나눗셈 연산에 비해 비용이 매우 낮기 때문입니다. 
제가 어셈블리를 잘은 모르지만....
사용되는 인스트럭션에 매우 적은것을 확인할 수 있습니다. 

# short circuit 원리의 활용

```c
void f1{
  int x = 10, y = 20;
  if((x < 5) && (y = 10))
    x += 10;
  printf("x=d, y=%d", x, y);
}
```

위 코드의 실행 결과를 예상해봅시다. 

1. `x=10, y=20`
1. `x=20, y=20`
1. `x=10, y=10`

답이 갈리는데는 이유가 있겟지만....

3라인에 교묘한 버그가 있다. 

`if((x < 5) && (y = 10))`

원래의 의도는 `y==10` 일텐데, 하나를 빼먹었습니다. 
그렇기 때문에 해당 부분은 y에 10이 대입되며, 10이 입력되어 해당 구문은 참이 됩니다. 

하지만... 해당 코드의 답은 `x=10, y=20` 입니다. 
`(x < 5)`가 거짓이기 때문에 그 뒤를 수행하지 않기 때문입니다. 
if는 구문이 참일때만 실행되기 때문에 이미 거짓이면 그 뒤는 더이상 볼 필요가 없습니다.

short circuit 의 원리는 다음과 같습니다. 

* && : 논리곱인 경우에 첫 비교문이 거짓이면 모두 거짓이므로 그 뒤의 비교문은 모두 수행하지 않는다.
* || : 논리합의 경우에는 첫 비교문이 참이면 모두 참이 되므로 그 뒤의 비교문은 모두 수행하지 않는다.

따라서 short circuit 최적화 방법은 다음과 같습니다. 

* && : 논리곱은 거짓일 확률이 높은 문장을 앞쪽에 둔다.
* || : 논리합은 참일 확률이 높은 문장을 앞쪽에 둔다.



