---
title: "[밑바닥부터 만드는 컴퓨팅] 03장 순차 논리"
excerpt: "해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 3장 내용을 정리하였습니다. "

categories:
  - 'make_computing_system'
tags:
  - 밑바닥부터 만드는 컴퓨팅
  - 순차 논리

toc: true
toc_sticky: true

date: 2021-12-01
last_modified_at: 2021-12-01
---

# 개요 

해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 3장 내용을 정리하였습니다.

1, 2장에서 만든 칩은 모두 조합칩이였습니다. 
조합칩은 입력값의 조합에만 의존하는 함수를 계산합니다. 
비교적 단순한 칩들은 중요한 기능을 하지만 상태를 유지하지는 않습니다. 
컴퓨터는 값을 계산하는것은 물론 시간이 지나도 데이터를 보존할 수 있어야 합니다. 
이러한 메모리 소자는 순자 칩으로 만듭니다. 

메모리 소자 구현은 동기화, 클로킹, 피드백 루프 등을 포함하는 복잡한 기술입니다. 
해당 장에서는 클럭과 플립플롭에 대해 살펴보고, 이 소자를 기본으로 하는 메모리 칩에 대해 알아보겠습니다. 

# 1. 배경 

## 1.1 클럭 

대부분의 컴퓨터는 연속적으로 신호를 발생하는 마스터 클럭으로 시간 진행을 표현합니다. 
보통 이 하드웨어는 (0, 1) (고, 저) (tic, tock) 등과 같이 두 신호 상태를 번갈아가면서 구현됩니다. 
이때 한 신호에서 다른 신호로 바뀔때의 시간, 예를들어 0에서 1로 바뀔때까지 시간을 사이클이라 부릅니다. 
현재의 클럭 사앹는 2진 신호로 표현되고, 이 신호는 하드웨어의 회로망을 통해 모든 컴퓨터에 있는 순차 칩들에 동시에 전달됩니다. 

## 1.2 플립플롭

컴퓨터에서 가장 기본적인 순차소자입니다. 
플립플롭에는 몇가지 종류가 있습니다. 
해당 책에서는 데이터 플립플롭(DFF)이라는 소자를 사용하며, 이 소자는 1비트 입력과 1비트 출력으로 구성됩니다. 
또한 이 DFF는 마스터 클럭에 따라 계속적으로 바뀌는 클럭 입력 신호를 받습니다. 
DFF는 데이터 입력과 클럭 입력을 종합하여 시간에 따른 동작을 수행합니다. 
```
out(t) = in(t-1)  // 1클럭 전의 값을 출력
```
이 기본 기능은 2진 셀에서 레지스터, 임시 기억장치 등 컴퓨터에서 상태를 유지하는 모든 하드웨어에 기초가 됩니다. 

## 1.3 레지스터 

레지스터는 시간이 지나도 값을 저장하고 로드할 수 있는 장치로 기본적인 저장기능인 `out(t) = in(t-1)` 을 구현한 것입니다. 

DFF 는 이전 입력을 출력하는 장치로 `out(t) = in(t-1)`을 수행합니다. 
이러한 특성을 이용하여 Mux와 DFF를 이용해 레지스터를 만들 수 있습니다. 

![image](https://user-images.githubusercontent.com/35713051/145034400-4cca1edb-6194-4f5e-ba41-cdf40952952d.png)

멀티플렉서의 선택비트는 전체 레지스터의 로드 비트가 됩니다. 
만약 레지스터가 새로운 값을 저장하게 하려면 in에 새로운 값을 넣고 로드 비트를 1로 설정하면 됩니다. 
그리고 다음번 변경 전까지 내부 값을 계속 유지하려면 로드 비트를 0으로 맞추면 됩니다. 

이와 같이 레지스터는 하나의 비트를 기억할 수 있습니다. 
이를 이용하여 더 많은 비트를 기억하는 레지스터를 만들 수 있습니다. 
멀티 비트를 저장하는 레지스터를 만드려먼 1비트 레지스터를 필요한 만큼 배열하면 됩니다. 
레지스터에 저장되는 멀티비트의 값은 보통 워드(word)라고 표현합니다. 

## 1.4 메모리 

레지스터를 이용하여 워드를 구성할 수 있으면 이제 임의의 길이의 메모리 뱅크를 구성할 수 있습니다. 

![image](https://user-images.githubusercontent.com/35713051/145034434-de83ca94-44c8-4d5c-96c9-949d2d956bbe.png)

위 그림은 1비트 레지스터와 멀티비트 레지스터입니다. 
값을 저장할 수 있는 크기를 제외하면 둘은 같은 기능을 수행합니다. 

![image](https://user-images.githubusercontent.com/35713051/145034463-3bfd4d7b-95d8-4e51-8793-59bcd65c5fa8.png)

위 그림은 여러개의 레지스터를 연결하여 만든 임시접근메모리(Random Access Memory)입니다. 
임시접근메모리는 접근 순서와 관계없이 무작위로 선택된 워드를 읽고 쓸수 있다는 말에서 나왔습니다.
즉 메모리 내의 어떤 워드라도 물리적 위치에 상관없이 같은 속도로 직접 접근이 가능하다는 뜻입니다. 

RAM은 데이터 입력, 주소 입력, 로드 비트라는 세가지 입력을 받습니다. 
이때 주소는 현재 시간 사이클에서 어떤 RAM 레지스터에 접근할지를 가르킵니다. 
읽기 연산(load=0)인 경우, RAM은 서너택된 레지스터의 값을 바로 출력합니다. 
쓰기 연산(load=1)인 경우, 다음 사이클 때 선택된 메모리 레지스터에 입력된 값을 받아 해당 값을 출력하기 시작합니다. 

RAM 장치의 기본 변수로는 각 워드의 비트 수를 뜻하는 데이터 폭과 RAM 내의 워드 수를 나타내는 크기가 있습니다. 
최신 컴퓨터는 보통 폭이 64비트이면서 크기가 수억만개에 달하는 RAM을 사용합니다. 

## 1.5 계수기

계수기(counter) 은 시간 단위마다 내부 상태의 값을 증가시키는 칩입니다.
`out() = out(t-1) + c` 를 수행합니다. 

[그림 추가 예정]

계수기는 컴퓨터에서 매우 중요한 역할을 수행합니다. 
일반적인 예로는 CPU에서 다음에 실행할 명령어의 추소를 나타내는 기능을 수행합니다. 

계수기 칩은 표준 레지스터의 입/출력 논리와 상태값에 상수를 더하는 논리가 조합된 것입니다. 
일반적으로 계수기는 값을 0으로 다시 맞추거나 새로운 값을 불러오거나 값을 증가 또는 감소시키는 기능이 추가됩니다. 

# 2. 명세

해당 절에서는 아래의 칩들을 정의합니다. 

* 데이터 플립플롭 (DFF)
* 레지스터 (DFF 기반)
* 메모리 뱅크 (레지스터 기반)
* 계수기 칩 (레지스터 기반)



