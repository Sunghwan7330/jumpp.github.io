---
title: "[밑바닥부터 만드는 컴퓨팅] 03장 순차 논리"
excerpt: "해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 3장 내용을 정리하였습니다. "

categories:
  - 'make_computing_system'
tags:
  - 밑바닥부터 만드는 컴퓨팅
  - 순차 논리

toc: true
toc_sticky: true

date: 2021-12-01
last_modified_at: 2021-12-01
---

# 개요 

해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 3장 내용을 정리하였습니다.

1, 2장에서 만든 칩은 모두 조합칩이였습니다. 
조합칩은 입력값의 조합에만 의존하는 함수를 계산합니다. 
비교적 단순한 칩들은 중요한 기능을 하지만 상태를 유지하지는 않습니다. 
컴퓨터는 값을 계산하는것은 물론 시간이 지나도 데이터를 보존할 수 있어야 합니다. 
이러한 메모리 소자는 순자 칩으로 만듭니다. 

메모리 소자 구현은 동기화, 클로킹, 피드백 루프 등을 포함하는 복잡한 기술입니다. 
해당 장에서는 클럭과 플립플롭에 대해 살펴보고, 이 소자를 기본으로 하는 메모리 칩에 대해 알아보겠습니다. 

# 1. 배경 

## 1.1 클럭 

대부분의 컴퓨터는 연속적으로 신호를 발생하는 마스터 클럭으로 시간 진행을 표현합니다. 
보통 이 하드웨어는 (0, 1) (고, 저) (tic, tock) 등과 같이 두 신호 상태를 번갈아가면서 구현됩니다. 
이때 한 신호에서 다른 신호로 바뀔때의 시간, 예를들어 0에서 1로 바뀔때까지 시간을 사이클이라 부릅니다. 
현재의 클럭 사앹는 2진 신호로 표현되고, 이 신호는 하드웨어의 회로망을 통해 모든 컴퓨터에 있는 순차 칩들에 동시에 전달됩니다. 

## 1.2 플립플롭

컴퓨터에서 가장 기본적인 순차소자입니다. 
플립플롭에는 몇가지 종류가 있습니다. 
해당 책에서는 데이터 플립플롭(DFF)이라는 소자를 사용하며, 이 소자는 1비트 입력과 1비트 출력으로 구성됩니다. 
또한 이 DFF는 마스터 클럭에 따라 계속적으로 바뀌는 클럭 입력 신호를 받습니다. 
DFF는 데이터 입력과 클럭 입력을 종합하여 시간에 따른 동작을 수행합니다. 
```
out(t) = in(t-1)  // 1클럭 전의 값을 출력
```
이 기본 기능은 2진 셀에서 레지스터, 임시 기억장치 등 컴퓨터에서 상태를 유지하는 모든 하드웨어에 기초가 됩니다. 

## 1.3 레지스터 

레지스터는 시간이 지나도 값을 저장하고 로드할 수 있는 장치로 기본적인 저장기능인 `out(t) = in(t-1)` 을 구현한 것입니다. 

DFF 는 이전 입력을 출력하는 장치로 `out(t) = in(t-1)`을 수행합니다. 
이러한 특성을 이용하여 Mux와 DFF를 이용해 레지스터를 만들 수 있습니다. 

![image](https://user-images.githubusercontent.com/35713051/145034400-4cca1edb-6194-4f5e-ba41-cdf40952952d.png)

멀티플렉서의 선택비트는 전체 레지스터의 로드 비트가 됩니다. 
만약 레지스터가 새로운 값을 저장하게 하려면 in에 새로운 값을 넣고 로드 비트를 1로 설정하면 됩니다. 
그리고 다음번 변경 전까지 내부 값을 계속 유지하려면 로드 비트를 0으로 맞추면 됩니다. 

이와 같이 레지스터는 하나의 비트를 기억할 수 있습니다. 
이를 이용하여 더 많은 비트를 기억하는 레지스터를 만들 수 있습니다. 
멀티 비트를 저장하는 레지스터를 만드려먼 1비트 레지스터를 필요한 만큼 배열하면 됩니다. 
레지스터에 저장되는 멀티비트의 값은 보통 워드(word)라고 표현합니다. 

## 1.4 메모리 

레지스터를 이용하여 워드를 구성할 수 있으면 이제 임의의 길이의 메모리 뱅크를 구성할 수 있습니다. 

![image](https://user-images.githubusercontent.com/35713051/145034434-de83ca94-44c8-4d5c-96c9-949d2d956bbe.png)

위 그림은 1비트 레지스터와 멀티비트 레지스터입니다. 
값을 저장할 수 있는 크기를 제외하면 둘은 같은 기능을 수행합니다. 

![image](https://user-images.githubusercontent.com/35713051/145034463-3bfd4d7b-95d8-4e51-8793-59bcd65c5fa8.png)

위 그림은 여러개의 레지스터를 연결하여 만든 임시접근메모리(Random Access Memory)입니다. 
임시접근메모리는 접근 순서와 관계없이 무작위로 선택된 워드를 읽고 쓸수 있다는 말에서 나왔습니다.
즉 메모리 내의 어떤 워드라도 물리적 위치에 상관없이 같은 속도로 직접 접근이 가능하다는 뜻입니다. 

RAM은 데이터 입력, 주소 입력, 로드 비트라는 세가지 입력을 받습니다. 
이때 주소는 현재 시간 사이클에서 어떤 RAM 레지스터에 접근할지를 가르킵니다. 
읽기 연산(load=0)인 경우, RAM은 서너택된 레지스터의 값을 바로 출력합니다. 
쓰기 연산(load=1)인 경우, 다음 사이클 때 선택된 메모리 레지스터에 입력된 값을 받아 해당 값을 출력하기 시작합니다. 

RAM 장치의 기본 변수로는 각 워드의 비트 수를 뜻하는 데이터 폭과 RAM 내의 워드 수를 나타내는 크기가 있습니다. 
최신 컴퓨터는 보통 폭이 64비트이면서 크기가 수억만개에 달하는 RAM을 사용합니다. 

## 1.5 계수기

계수기(counter) 은 시간 단위마다 내부 상태의 값을 증가시키는 칩입니다.
`out() = out(t-1) + c` 를 수행합니다. 

![image](https://user-images.githubusercontent.com/35713051/146675423-29d71c48-eb94-43e1-acfb-2c7e9b8f60f3.png)

계수기는 컴퓨터에서 매우 중요한 역할을 수행합니다. 
일반적인 예로는 CPU에서 다음에 실행할 명령어의 추소를 나타내는 기능을 수행합니다. 

계수기 칩은 표준 레지스터의 입/출력 논리와 상태값에 상수를 더하는 논리가 조합된 것입니다. 
일반적으로 계수기는 값을 0으로 다시 맞추거나 새로운 값을 불러오거나 값을 증가 또는 감소시키는 기능이 추가됩니다. 

# 2. 명세

해당 절에서는 아래의 칩들을 정의합니다. 

* 데이터 플립플롭 (DFF)
* 레지스터 (DFF 기반)
* 메모리 뱅크 (레지스터 기반)
* 계수기 칩 (레지스터 기반)

# 2.1 데이터 플립플롭

데이터 플립플롭 게이트는 모든 메모리 소자의 기본 부품이 됩니다. 
DFF 게이트는 1비트 입력을 받아 1비트를 출력합니다. 

```
칩 이름: DFF
입력: in
출력: out
기능: out(t)-in(t-1)
```

Nand 게이트와 더불어 DFF 게이트는 컴퓨터 아키텍쳐에서 가장 기본이 됩니다. 
특히 컴퓨터 내 모든 조합 칩(레지스터, 메모리, 계수기)들은 수많은 DFF 로 구성됩니다. 
이 DFF 들은 마스터 클럭에 연결되어 행동하게 됩니다. 
클록 사이클이 시작할 때 모든 DFF 출력들은 전 사이클에 입력에 따라 맞춰집니다. 
그 시간 외에는 DFF가 잠금 상태가 됩니다. 
즉 입력이 변해도 곧바로 출력에 영향을 받지 않습니다. 
컴퓨터에서는 이러한 연산이 초당 십억번씩 모든 DFF에서 수행됩니다. 

# 2.2 레지스터 

우리가 비트 또는 2진 셀이라 부르는 1비트 레지스터는 0 또는 1의 값을 저장하도록 설계된 소자입니다. 
칩 인터페이스는 데이터 비트를 전달하는 입력 핀과 쓰기 기능을 설정하는 load 핀, 그리고 셀의 현재 상태랄 내보내는 출력 핀으로 이뤄집니다. 

2진 셀의 인터페이스와 API는 다음과 같습니다. 
```
칩 이름: Bit
입력: in, load
출력: out
기능: If load(t-1) then out(t)=in(t-1)
      else out(t)=out(t-1)
```

레지스터ㅓ는 입력 핀과 출력 핀이 멀티비트를 처리할 수 있다는 점을 제외하고는 기본적인 2진 셀과 같습니다. 

```
입력: in[16], load
출력: out [16]
기능: If load(t-1) then out(t)=in(t-1)
      else out(t)=out(t-1)
설명: "="는 16비트 연산이다.
```

* 읽기 : 레지스ㅓ 내부 값을 읽으려면 단순히 출력 신호를 보면 됩니다. 
* 쓰기 : 레지스터에 새로운 값 d를 쓰려면 in에 d를 입력하고, load에 명련신호(1)을 줍니다. 다음 클럭 사이클이 되면 레지스터는 새로운 데이터 값을 받아 d를 내보내기 시작합니다. 
 
# 2.3 메모리 

RAM은 직접 접근 메모리 장치로, n개의 w-비트 레지스터를 배열하고 직접 접근 회로를 연결한 소자입니다. 
메모리에 들어간 레지스터의 수(n) 및 비트수(w)는 각각 메모리의 크기(size)와 폭(width)이라고 부릅니다. 

이제 폭이 16비트이고 크기가 다양한 메모리 계층을 구축해야 합니다. (RAM8, RAM64, RAM512 등)
이러한 메모리 칩들은 모두 API가 동일합니다. 

![image](https://user-images.githubusercontent.com/35713051/146675445-394deb17-04c4-466e-a4da-012929e4ec4a.png)


```
칩 이름: RAMn // no k 목록은 맨 아래에 있음
입력: in(16), address[k], load
출력: out [16]
기능: out(t)=RAM (address(t)](t)
      If load(t-1) then
        RAM (address(t-1)](t)=in(t-1)
설명: "="는 16비트 연산이다.
```

* 읽기 : 레지스터 번호 m에 해당하는 주소의 내부 값을 읽으려면 address에 m을 넣습니다. 
그러면 RAM의 직접 접근 논리에 따라 레지스터 번호 m이 선택되고, RAM의 출력 핀에 그 값이 출력됩니다. 
이 과정은 조합 연산으로 클럭의 영향을 받지 않습니다. 

* 쓰기 : 세로운 데이터 값 d를 레지스터 번호 m 에 해당하는 주소에 쓰려면 address에 m을, in에 d를 입력하고 load 비트를 활성화합니다. 
RAM의 직접접근 논리에 따라 레지스터 번호 m이 선택되고, load 비트로 인해 RAM이 쓰기 모드로 바뀝니다. 
다음 클럭 사이클에서 선택된 레지스터가 새로운 값을 받아 출력하기 시작합니다. 

# 2.4 계수기 

계수기는 그 자체로는 독립적인 추상화 계층입니다. 
컴퓨터에서 계수기가 어떤식으로 사용되는지 간단하게만 살펴보겠습니다. 

컴퓨터가 다음번 실행할 명령의 주소를 기록하는 계수기 칩이 있다고 생각해보겠습니다. 
일반적인 상ㅌ태에서는 계수기는 매 클럭 사이클마다 상태값을 1씩 증가시켜 컴퓨터가 다음 명령을 불러올 수 있게 합니다. 
만약 if문과 같은 분기로 인해 명령 주소를 이동할 때는 계수기의 값을 주소만큼 더하여 jump하도록 할 수 있습니다. 
또한 프로그램의 시작주소로 jump 하여 프로그램을 재시작할 수도 있습니다. 

이러한 기능을 생각하고 보면 reset 과 inc라는 제어비트가 추가된 것을 제외하면 레지스터와 비슷합니다. 
inc=1 일때 계수기는 매 클럭사이클마다 상태 값을 증가시키고 `out(t)=out(t-1)+1` 을 출력합니다. 
reset 비트를 활성화하면 계수기를 0으로 설정할 수 있습니다. 
이때 in 에 특정 값을 넣으면 해당 값으로 초기화됩니다. 

# 3. 마무리 

1, 2장까지는 그래도 천천히 보면 이해할만한 내용이였는데, 3장은 클럭 개념이 들어가면서 조금 많이 어려워졌습니다 ㅠㅠ
저도 책을 보고 작성하면서 개념적인 부분은 이해했지만, 아직 누구에게 자세히 설명하기는 힘들어보입니다. 
실습을 하여 실제 구현을 해보면 조금 더 이해가 잘 될 수 있을듯 합니다. 


