---
title: "[밑바닥부터 만드는 컴퓨팅] 04장 기계어"
excerpt: "해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 4장 내용을 정리하였습니다. "

categories:
  - 'make_computing_system'
tags:
  - 밑바닥부터 만드는 컴퓨팅
  - 기계어

toc: true
toc_sticky: true

date: 2021-12-28
last_modified_at: 2021-12-28
---

# 개요 

해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 4장 내용을 정리하였습니다.


# 1. 배경 

해당 장에서는 언어에 대해 설명합니다. 
하드웨어 플랫폼에 대한 자세한 설명은 다음장에서 설명합니다. 
기계어를 일반적으로 설명하는데는 프로세서, 메모리, 레지스터로 설명할 수 있겠습니다. 

## 1.1 기계

기계어는 프로세서와 레지스터들을 이용하여 메모리를 조작할 수 있도록 미리 정의한 규칙이라 할 수 있습니다. 

### 1.1.1 메모리 

메모리는 컴퓨터에서 데이터와 명령어를 저장하는 하드웨어 장치들을 대략적으로 통칭하는 장치입니다.  (주로 RAM을 사용합니다)
메모리는 word나 location이라 불리는 정해진 폭의 셀들이 연속적으로 배열되어 있으며, 이 셀은 각각의 주소를 가지고 있습니다. 
그렇기에 각각의 word는 address를 통해 특정할 수 있습니다. 
앞으로 이러한 단어들을 memory, RAM, M 과 같은 용어로 표현됩니다. 

### 1.1.2 프로세서 

중앙처리장치 또는 CPU라고 불리는 프로세서는 기초 연산을 수행하는 장치입니다. 
산술 및 논리연산, 메모리 접근 연산, 제어, 분기와 같은 연산이 포함된다. 
이와 같은 연산의 피연산자들은 선택된 메모리 위치와 레지스터에 있는 바이너리 값이 됩니다.. 
연산의 결과값은 선택된 메모리 주소 또는 레지스터에 저장됩니다.

### 1.1.3 레지스터

메모리 접근 연산은 상대적으로 느리고 긴 명령어가 필요합니다. 
그렇기 때문에 대부분의 프로세서는 값 하나를 저장할 수 있는 레지스터를 여러개 두고 있습니다. 
레지스터는 프로세서의 바로 옆에 위치합니다. 
그렇기때문에 프로세서가 명령어와 데이터를 빠르게 처리할 수 있는 로컬 고속 메모리 역할을 합니다. 
레지스터가 있기 때문에 메모리 접근 단계를 줄일 수 있으며, 이로인해 프로그램의 실행 속도가 올라가게 됩니다. 

## 1.2 언어

기계어 프로그램은 명령어를 코드화한 것입니다. 
예를 들어 16비트 컴퓨터라고 하면 명령어는 `1001010110100111` 과 같이 16비트의 바이너리로 구성되어 있습니다. 
이러한 명령어가 무엇을 뜻하는지 알려면 하드웨어 플랫폼의 명령 집합을 알아야 합니다. 

예를들어 어떤 기계어가 4개의 필드로 명령이 구성되어 있고, 맨 왼쪽에는 CPU 연산 코드, 나머지 세개는 피연산자라고 생각해봅시다. 
16비트를 4비트로 나누었을때 맨 처음의 4비트로 CPU의 연산을 결정하고, 나머지 세부분은 피연산자가 될 수 있습니다. 
CPU 연산을 해석하여 R1 + R2를 수행하여 R3에 저장하라는 해석이 될 수 있습니다. 

2진 코드는 암호같아보이기 때문에 보통은 연상기호를 사용하도록 되어 있습니다. 
예를들어 연산코드 1010이 ADD라고 하고 레지스터들을 R1, R2와 같은 기호로 표기할 수 있습니다. 
그러면 `1010000100100011`은 `1010`, `0001`, `0002`, `0003`으로 나눌 수 있으며, 이는 연상기호로 `ADD R1 R2 R3` 으로 표현할 수 있습니다. 

이 표기법을 더 추상화한다면 기호를 읽는것 뿐만 아니라 2진 명령어 대신 기호를 텍스트로 입력하여 프로그램을 작성할 수도 있습니다. 
또한 이 명령어들을 텍스트 처리 프로그램으로 분석하여 2진 코드로 변환할 수 있을 것입니다. 
이러한 기호 표기법을 어셈블리 언어 또는 어셈블리라고 부르며, 어셈블리를 2진 코드로 번역하는 프로그램을 어셈블러 라고 합니다. 

CPU마다 연산이나 레지스터의 종류, 어셈블리 문법 등이 다를 수 있습니다. 
하지만 문법이 다르더라도 일반적으로는 비슷한 명령으로 되어있습니다. 

## 1.3 명령

### 1.3.1 산술 및 논리연산 

컴퓨터에서 산술 연산은 더하기, 빼기, 곱하기, 나누기 와 같은 연산을 의미합니다. 
뿐만 아니라 컴퓨터는 And, Or, Shift, 반전 등와 같은 비트 논리연산도 필요합니다. 
다음은 일반적인 기계어 문법으로 작성된 예시입니다. 

```
ADD R2, R1, R3 // R2<-R1+R3, 여기서 R1,R2,R3는 레지스터다.
ADD R2, R1, foo // R2<-R1+foo, 여기서 foo는 사용자가 정의한 이름으로,
               // foo가 가리키는 메모리 주소의 값을 뜻한다.
AND R1, R1, R2 // R1<-R1과 R2을 비트 단위로 And 연산한 결과
```

### 1.3.2 메모리 접근 

메모리 접근 명령은 두 부류로 나뉩니다. 
산술 및 논리연산 명령은 레지스터 외에도 특정 메모리 주소에 접근할 수 있습니다. 
또는 어느 컴퓨터나 지원하는 load, store 명령을 이용해 레지스터와 메모리 사이에 데이터를 이동시키는 명령이 있습니다. 

메모리 접근 명령에는 주소 지정 모드가 있습니다. 
컴퓨터 CPU 마다 다를 수 있지만 일반적으로 아래의 방법들을 지원합니다. 

* 직접 주소 지정 방식
  * 특정 주소에 직접 쓰거나, 그 주소를 나타내는 기호를 활용 
```
LOAD R1, 67 // R1<-Memory [67]
            // 또는 bar가 에모리 주소 67을 나타낸다고 가정하면
LOAD R1, bar // R1<-Memory (67)
```

* 즉시 주소 지정 방식
  * 명령어 코드에 있는 상수를 불러오는데 쓰임 
```
LOAD R1,67 // R1<-67
```

* 간접 주소 지정 방식
  * 명령어에 메모리 주소가 하드코딩되지 않고, 필요한 주소값을 저장하고 있는 메모리 위치를 참조하는 방법
  * 이 주소방식은 poointer을 사용할 때 쓰임
```
// x = foo[j] 또는 x = *(foo + j)
ADD R1, foo, j // R1 <- foo+j
LOAD R2, R1    // R2 <- Memory[R1]
STR R2, x      // x <- R2
```

### 1.3.3 제어 흐름 

프로그램은 보통 명령어를 순차작으로 실행합니다. 
하지만 상황에 따라 다음 명령어가 아닌 특정 위치의 명령어를 수행하기도 합니다. 
if, switch 문과 같은경우 상황에 맞게 명령어를 분기해줘야합니다. 
또한 for, while 과 같은 반복문은 loop의 끝에 오면 다시 위의 명령어를 실행하도록 해야합니다. 

모든 기계어들은 이런 프로그래밍 구조를 지원하기 위해 프로그램 내에 선택된 주소의 명령으로 점프하는 기능을 가지고 있습니다. 

# 2. 핵 기계어 명세 

## 2.1 개요 

핵 컴퓨터는 폰 노이만 플랫폼입니다. 

CPU, 명령용과 데이터용으로 분리된 두 개의 메모리 모듈, 두개의 메모리 매핑 I/O 장치로 구성된 16비트의 장치입니다. 

### 2.1.1 메모리 주소 공간

핵에서는 주소 공간이 명령어 메모리와 데이터 메모리라는 두 부분으로 분리되있습니다. 
폭이 16비트인 두 메모리 공간은 15비트로 최대 32K 개의 16비트 워드를 주소에 할당할 수 있습니다. 

핵의 CPU는 명령어 메모리에 존재하는 프로그램만을 수행합니다. 
명령어 메모리는 읽기전용입니다. 
내부적인 방법으로는 프로그램을 로드할 수 없고 외부적인 방법으로만 가능합니다. 
프로그램을 미리 ROM에 입력하는 방식입니다. 

핵의 하드웨어 시뮬레이터에서는 이런 ROM 교체 방식을 시뮬레이션하기 위해 텍스트파일에 있는 기계어 프로그램을 명령어 메모리 로드하는 기능을 제공하게 됩니다. 

### 2.1.2 레지스터

핵 시스템에는 D와 A라 불리는 16비트의 레지스터 두개가 있습니다. 
이 레지스터들은 `A=D-1`과 같은 산술 명령이나 D=!A같은 논리 명령으로 직접 조작됩니다. 
D는 데이터 값을 저장하는 용도로 쓰이는 반면 A 는 데이터 레지스터와 주소 레지스터라는 두 역할을 합니다. 


## 2.2 A-명령어

A-명령어는 A레지스터에 15비트 값을 설정하는데 씁니다. 

이 명령어는 컴퓨터가 A 레지스터에 특정 값을 저장하도록 명령합니다. 
예를들어 `@5` 명령어는 `0000000000000101` 와 동일한데, A 레지스터에 2진수로 표현된 5를 저장하라는 뜻을 의미합니다. 

A-명령어는 세가지 용도로 쓰입니다. 

* 상수 입력 용도 
* C 명령어에서 주소값을 참조할 수 있도록 A 레지스터에 데이터 주소 입력
* A 레지스터에 점프할 주소를 미리 입력 

![image](https://user-images.githubusercontent.com/35713051/149616961-5ef4b9f1-85ce-4e34-bf61-b1ac57d0f20c.png)

## 2.3 C-명령어

C-명령어는 핵 플랫폼에서 거의모든 일을 수행하는 명령어입니다. 
C-명령어는 A명령어와 함께 쓰이면 본 책에서 만들 컴퓨터에서 가능한 모든 연산을 수행합니다. 

맨 왼쪽 비트 값이 1이면 명령어가 C-명령어임을 나타내는 코드입니다. 
그 다음의 두 비트는 사용되지 않습니다. 
나머지 비트들은 명령어에 있는 세가지 필드를 뜻합니다. 
`comp` 필드는 ALU 가 할 연산이 무엇인지를 뜻합니다. 
`dest` 필드는 계산된 값을 어디에 저장할지 가리킵니다. 
`jump` 필드는 점프 조건으로 다음에 불러와서 실행할 명령어가 무엇인지를 의미합니다. 

![image](https://user-images.githubusercontent.com/35713051/149616950-3b196461-006c-4f2c-99a6-668c237d56a6.png)

### 2.3.1 계산 필드 

핵 ALU 는 D와 A 및 M 레지스터 상에서 미리 정해진 함수들을 계산합니다. 
계산할 함수는 명령어의 `comp` 필드에서 정의되는데, 1개의 a-비트 6개의 c-비트로 총 7비트로 표현됩니다. 
이 7비트 패턴으로는 최대 128개의 서로 다른 함수를 코드화할 수 있습니다. 
아래의 그림은 그 중 28개의 패턴만 언어 명세에 포함됩니다. 

![image](https://user-images.githubusercontent.com/35713051/149616933-6cbaa371-0a05-4b72-8981-e5422a1cee54.png)

C-명령어의 형식은 `111a cccc ccdd djjj`로 구성되어 있습니다. 
ALU에 `D-1`연산, 즉 D레지스터의 값에 1을 빼는 연산을 할 떄의 명령어를 확인해보겠습니다. 
그림에서 보았을 때 `D-1`의 C-명령어 계산 필드는 `001110` 입니다. 
따라서 `D-1`은  `1110 0011 1000 0000` 로 표현할 수 있습니다. 
`D|M` 은 `1111 0101 0100 0000`이며, 상수-1 연산은 `1110 1110 1000 0000` 이 됩니다. 

### 2.3.2 목적지 필드

C-명령어의 comp 부분에서 계산된 값은 3비트 dest 부분이 가리키는 몇가지 목적지에 저장됩니다. 
첫번째와 두번째 d-비트는 계산된 값을 각각 A 레지스터와 D레지스터에 저장할지를 결정하는 코드입니다. 
세번째 d-비트는 계산된 값을 M에 저장할지를 결정하는 코드입니다. 

C-명령어의 형식은 `111a cccc ccdd djjj` 입니다. 
만약 메모리의 [7] 의 값을 1만큼 증가시키고 그 결과를 D레지스터에 저장하는 명령어는 아래와 같습니다. 

```
0000 0000 0000 0111  // @7
1111 1101 1101 1000  // MD = M + 1

```

[그림 추가 예정]

