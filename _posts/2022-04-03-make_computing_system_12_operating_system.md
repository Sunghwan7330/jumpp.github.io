---
title: "[밑바닥부터 만드는 컴퓨팅] 12장 운영체제"
excerpt: "해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 12장 내용을 정리하였습니다. "

categories:
  - 'make_computing_system'
tags:
  - 밑바닥부터 만드는 컴퓨팅
  - 운영체제

toc: true
toc_sticky: true

date: 2022-04-15
last_modified_at: 2022-04-15
---

# 1. 배경 

## 1.1 수학 연산 

컴퓨터 시스템은 덧셈, 곱셈, 나눗셈같은 수학 연산을 지원합니다. 
덧셈의 경우 ALU 수준에서 구현되며, 이는 3장에서 구현했었습니다. 
곱셈 및 나눗셈같은 연산들은 하드웨어나 소프트웨어에서 처리되며, 비용 / 성능 요구사항에 따라 구현 방식이 달라집니다. 
해당 절에서는 곱셈, 나눗셈 및 제곱근 연산을 OS 수준에서 구현합니다. 

### 1.1.1 효율성 우선 

수학 알고리즘은 n비트 2진수로 연산되며, 전형적인 컴퓨터 아키텍쳐에서는 32비트 또는 64비트를 사용합니다. 

예를 들어 `x * y` 를 for문을 이용해 덧셈으로 구현한다고 해보겠습니다. 
이때 y의 값이 최대값이라면 현존하는 가장 빠른 컴퓨터라고 해도 몇년이 걸릴수도 있습니다. 
반면 곱셈 알고리즘을 이용하여 수행한다면 빠르게 수행이 가능합니다. 

보통 알고리즘의 실행시간을 표기할때 보통 ‘빅 오’ 표기법인 O(n)을 사용합니다. 

### 1.1.2 곱셈

[그림]

위 그림의 알고리즘은 n 비트 숫자에 O(n) 덧셈 연산을 수행합니다. 
비트 표현을 왼쪽으로 한 칸 이동시키거나 shiftedX 를 자기 자신에 더하면 shifted * 2 를 효율적으로 얻을 수 있습니다. 
두 연산 모두 ALU 연산으로 쉽게 수행할 수 있습니다. 

### 1.1.3 나눗셈 

```
divide (x, y):
  // x>=0이고 y > 0일 때 x/y의 정수부
  if y>x return 0
    q = divide(x, 2-y)
  if (x - 2 * q * y) < y
    return 2 * q
  else
    return 2 * q + 1
```

이 알고리즘의 실행 시간은 재귀의 깊이에 좌우됩니다. 
재귀의 각 단계에서 y의 값에 2가 곱해지고, y>x이면 중단하므로 재귀의 깊이는 x의 비트수인 n으로 제한됩니다. 
그리고 재귀의 단계마다 상수 횟수만큼 덧셈, 뺄셈 및 곱셈 연산이 수행되므로 전체 실행시간은 O(n)이 됩니다. 

### 1.1.4 제곱근 

제곱근은 뉴턴 랩슨(newton-Raphson) 방법이나 테일러 급수 전개(Taylor series expansion) 과 같은 효율적인 계산 방법이 있습니다.
하지만 여기서는 더 간단한 방법으로 충분합니다. 
제곱근 함수 `y = √(x)` 에는 다음과 같은 속성이 있습니다. 

* 단조 증가함수
* 역함수 `x = y^2` 를 계산하는 방법을 알고 있음 

```
sqrt(x):
  // y =vx의 정수부를 계산한다. 전략:
  // y≤x< (y+1)인 정수 y를 찾는다. (0≤x<2일 때)
  // 0...22-1의 범위에서 2진 탐색을 수행한다.
  y = 0
  for j = n/2 - 1 … 0 do
    …..
  return y
```

## 1.2 숫자의 문자열 표현

컴퓨터는 숫자를 내부적으로는 2진 코드로 표현합니다. 
OS는 특정 2진 코드를 문자로 변경하여 제공하는 루틴이 포함되있습니다.
간단한 문자들은 ASCII 코드로 정리되어 있습니다. 

문자 ‘0’ 은 0x30이며 문자’9’는 0x39 입니다. 
아래의 예시는 문자를 숫자로, 숫자를 문자로 변환하는 방법입니다. 

```
// 음수가 아닌 숫자를 문자열로 변환한다.
int2String(n):
  lastDigit=n96 10
  c = lastDigit을 나타내는 문자
  if n < 10
    return c (문자열 타입으로 반환)
  else
    return int2String(n/10).append(c)
```

```
// 문자열을 숫자로 변환한다.
string2Int(s);
  v = 0
  for i=1 ... (s의 length) do
    d = s[i]의 int 값
    v = v * 10 + d
  return v
  // s[1]이 s의 가장 윗자리 숫자를
  // 나타내는 문자라 가정한다.
```
