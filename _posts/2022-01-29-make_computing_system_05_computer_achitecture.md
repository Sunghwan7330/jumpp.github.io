---
title: "[밑바닥부터 만드는 컴퓨팅] 05장 컴퓨터 아키텍쳐"
excerpt: "해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 5장 내용을 정리하였습니다. "

categories:
  - 'make_computing_system'
tags:
  - 밑바닥부터 만드는 컴퓨팅
  - 컴퓨터 아키텍쳐

toc: true
toc_sticky: true

date: 2022-01-29
last_modified_at: 2022-01-29
---

# 개요 

해당 내용은 '밑바닥부터 만드는 컴퓨팅 시스템' 책의 5장 내용을 정리하였습니다.

# 1. 배경

## 1.1 내장식 프로그램 개념

컴퓨터는 정해진 명령어 집합들을 실행하는 고정된 하드웨어 플랫폼에 기반합니다. 
동시에 컴퓨터가 실행하는 명령어들은 기본 블록이 되어 무한히 복잡한 프로그램으로 조합됩니다. 
이러한 프로그램들은 하드웨어에 내장되지 않고 컴퓨터의 메모리상에 데이터처럼 저장되고 연산되는데, 이를 소프트웨어라고 부릅니다. 
사용자가 현재 실행하는 소프트웨어에 따라 연산이 달라지므로, 같은 하드웨어라고 하더라도 어떤 프로그램을 실행하느냐에 따라 제각각의 일을 수행할 수 있습니다. 

## 1.2 폰 노이만 구조 

폰 노이만 기계는 현대의 거의 모든 컴퓨터 플랫폼의 개념적 설계도이자 실제 구조이기도 합니다. 

![image](https://user-images.githubusercontent.com/35713051/152168016-1b3ca132-9572-4662-8a18-9e72322dae16.png)

폰 노이만 구조는 중앙 처리 장치를 기반으로 하며, 이 장치는 메모리 장치와 통신하고, 입력 장치에서 데이터를 받고, 출력 장치에 데이터를 보내는 일을 합니다. 
이 구조의 중심에 내장식 프로그램의 개념이 있습니다. 
즉 메모리는 컴퓨터가 조작하는 데이터 뿐만 아니라, 컴퓨터가 수행하는 명령어도 저장합니다. 

## 1.3 메모리 

폰 노이만 기계의 메모리는 데이터와 명령어, 두 종류의 정보를 저장합니다. 
이 두 정보는 보통 다르게 취급되며, 일부 컴퓨터에서는 메모리 장치를 분리해서 따로 저장하기도 합니다. 
두 정보의 기능은 다르지만, RAM에 2진수로 저장된다는 점은 같습니다. 
이 구조는 word나 loaction이라 불리는 정해진 크기의 셀들이 배열된 것으로 유일한 주소를 가집니다. 

### 1.3.1 데이터 메모리 

고수준 프로그램은 변수, 배열, 객체같은 추상적 개념들을 다룹니다. 
이런 추상적 데이터들은 기계어로 번역하면 2진 숫자열로 바뀌어 데이터 메모리에 저장됩니다. 
주소를 통해 데이터 메모리에서 한 word를 선택하면, 그 word에 읽거나 쓰는게 가능해집니다. 
읽기의 경우 word의 값을 가져오며, 쓰기의 경우 word의 위치에 새로운 값을 덮어씌웁니다. 

### 1.3.2 명령어 메모리 

고수준 명령어들을 기계어로 변역하면 2진수 기계어를 뜻하는 word가 됩니다. 
이 명령어들은 메모리에 저장됩니다. 
컴퓨터 연산의 각 단계마다 CPU는 명령어 메모리에서 하나의 word를 인출(fetch)하여 해석한 뒤 정해진 명령어를 수행하고, 다음 수행할 명령어를 찾아냅니다. 
그래서 명령어 메모리의 내용을 바꾸면 컴펴튜 연산이 완전히 바뀌게 됩니다. 

명령어 메모리에 상주하는 명령어는 기계어라 불리는 미리 정의된 형식으로 작성됩니다. 
어떤 컴퓨터에서는 연산과 피연산자를 나타내는 코드가 한 word로 표현되는 반면 어떠한 컴퓨터는 여러 word로 쪼개져 기술되기도 합니다. 

## 1.4 중앙 처리 장치 

중앙 처리 장치(CPU)는 불러온 프로그램의 명령어를 실행하는 일을 담당합니다. 
CPU는 이 명령어들을 이용해 다양한 계산을 수행하고, 메모리의 값을 읽거나 쓰며, 조건에 따라 다른 명령어로 점프합니다. 
CPU는 이러한 작업을 수행할 때 산술 논리 연산장치(ALU), 레지스터, 제어장치 세가지의 주요 하드웨어가 관여합니다. 

### 1.4.1 산술 논리 연산 장치 (ALU)

ALU는 컴퓨터에서 지원하는 모든 저수준 산술 연신 및 논리 연산을 수행하는 장치입니다. 
앞에서 실습한 바와 같이 두 값을 더하거나, 비트 조작 등의 연산을 수행합니다. 

### 1.4.2 레지스터 

CPU는 간단한 계산을 빠르게 수행하도록 설계됩니다. 
계산 성능을 올리려면 이런 계산의 결과를 매번 메모리에 로드하고 저장하기보다는, CPU 근처에 저장할 필요가 있습니다. 
이러한 이유로 모든 CPU는 word를 저장할 수 있는 고속 레지스터를 가지고 있습니다. 

### 1.4.3 제어 장치

요즘의 컴퓨터 명령어는 보통 폭이 32비트 또는 64비트인 2진 코드로 표현됩니다. 
이러한 명령어 하나가 실행되려면 명령어를 해석해서 다양한 하드웨어 장치가 명령어를 어떻게 실행해야 하는지 정보를 알아내고 각각에 전달해야 합니다. 
명령어 해석은 제어 장치에서 이뤄지며, 동시에 이 장차는 어떤 명령어를 인출하고 다음에 실행해야 하는지 알아내는 역할도 합니다. 

CPU 연산은 이제 명령어를 메모리에서 인출하고, 해석하고, 실행하고, 다음 명령어를 인출하는 루프가 반복되는 것을 알 수 있습니다. 
명령어가 실행될 때는 ALU에서 어떤 값을 계산하고, 내부 레지스터를 조작하고, 메모리에서 word 하나를 읽고, 메모리에 단어 하나를 쓰는 작업들 중 하나 이상을 하게 됩니다. 
CPU는 이 작업을 실행하는 과정에서 다음에 인출하고 실행할 명령어를 찾는 작업도 합니다.

## 1.5 레지스터 

메모리 접근 작업은 컴퓨터의 입장에서는 느린 작업입니다. 
CPU가 메모리 주소 j의 내용을 가져오는 과정은 다음과 같습니다.  

1. j가 CPU에서 RAM으로 전달됨 
1. RAM의 직접 접근 논리에 따라 주소가 j인 메모리 레지스터가 선택됨 
1. RAM[j]의 내용이 CPU로 전달됨 

레지스터는 데이터 추출 및 저장 기능이 RAM과 동일하지만, 데이터가 옮겨지거나 메모리를 탐색하는 비용이 들지 않습니다. 
그 이유로 첫번째는 CPU칩 내부에 물리적으로 위치하여 바로 접근이 가능하고, 두번째로는 메모리 셀은 수백만개가 있는 반면 레지스터는 소수만 있기 때문입니다. 
따라서 조작할 레지스터를 지정하는데 몇 개의 비트만 사용하므로 명령어 길이도 더 짧게 됩니다. 

CPU들은 다양한 종류의 레지스터를 각각 다른 개수만큼 사용합니다. 
어떤 컴퓨터 아키텍쳐에서는 다음과 같은 레지스터가 하나 이상의 기능을 수행합니다. 

### 1.5.1 데이터 레지스터 

이 레지스터들은 CPU의 단기 기억 메모리 기능을 합니다. 
예를 들어 `(a-b)*c` 값을 계산한다고 할 때, 먼저 `(a-b)` 의 값을 계산하고 기억하애 합니다. 
이 중간 값을 메모리에 저장하는 것 보다 금방 사용할 것이기 때문에 내부에 저장하는 것이 더 좋습니다. 
이러한 용도로 데이터 레지스터를 사용합니다. 

요약하자면 데이터 레지스터는 어떠한 연산을 수행하였을 때의 결과값을 저장하는 레지스터입니다. 

### 1.5.2 주소 지정 레지스터 

CPU는 데이터를 읽고 쓰기 위해 계속해서 메모리에 접근해야 합니다. 
그리고 이러한 연산을 하게되면 접근해야 할 메모리 워드를 지정해야 합니다. 

주소가 현재 명령어에 포함될 수도 있고, 예전 명령어의 실행 결과를 이용하기도 합니다. 
이 중 후자의 경우 주소가 될 값을 저장하는데, 이때 주소 지정 레지스터가 사용됩니다. 

요약하자면 주소 지정 레지스터는 어떠한 메모리에 접근하기 위한 주소값을 저장하는 레지스터입니다. 

### 1.5.3 프로그램 계수기 레지스터 

프로그램을 실행할 때 CPU 명령어 메모리에서 인출해야 할 다음 명령어의 주소를 항상 알고 있어야 합니다. 
이 주소는 PC(program counter)라 불리는 레지스터가 저장하고 있습니다. 
그리고 PC의 값은 명령어 메모리에서 인출할 명령어의 주소로 쓰입니다. 

PC는 명령어를 수행한 뒤 다음 명령어를 가르키도록 일정하게 증가하며, 명령어의 수행 결과로 메모리 주소가 jump 하는 경우에 PC에 해당 주소를 저장하여 해당 메모리의 명령어를 수행하도록 하게 됩니다. 

요약하자면 PC 레지스터는 CPU가 수행하기 위한 명령어 주소를 저장하는 레지스터입니다. 

