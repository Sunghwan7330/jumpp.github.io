---
title: "[임베디드 C를 윈한 TDD] 13장 레거시 코드에 테스트 추가하기"
excerpt: "해당 내용은 '임베디드 C를 위한 TDD' 책의 13장 내용을 정리하였습니다. "

categories:
  - 'embedded_c_tdd'
tags:
  - 임베디드
  - TDD

toc: true
toc_sticky: true

date: 2022-08-09
last_modified_at: 2022-08-09
---

# 개요 

6장을 포스팅한 뒤 갑자기 13장을 포스팅하게 되었습니다. 

앞부분에서 TDD 가 무엇인지를 파악한 뒤 필요한 부분 부터 보려고 하다 보니까 13장을 우선적으로 보게 되었습니다. 


# 레거시 코드 변경 정책 

* 새로운 코드는 테스트 주도로 개발한다
* 레거시 코드를 수정하기 전에 테스트를 추가한다 
* 레거시 코드에서 변경되는 것들은 테스트 주도로 개발한다 

# 보이스카우트 원칙 

보이스카우트는 `캠프를 떠날 때는 처음 왔을 때보다 더 깨끗해야 한다` 라는 단순한 원칙을 따릅니다. 
즉, 수정한 부분에 대해서는 최대한 깔끔하게 코드를 깔끔하게 작성해야 한다는 의미입니다. 

## 긴 함수에 추가하기 

긴 함수는 따로 뽑아내어 이름을 붙일만한 내용이 많을 것입니다. 
예시로 긴 함수에 새로 세줄을 추가하고자 한다면 다섯줄을 추출하도록 해보겠습니다. 
결과적으로 이 함수는 두줄이 짧아집니다. 

단, 기존 동작을 보존하기 위한 테스트는 먼저 추가되어야 합니다. 

## 복잡한 조건식에 추가하기 

조건식을 추출하여 이름을 잘 붙인 도움 함수로 만드는 방법입니다. 

새로 추가한 코드의 조건식이 다른 모듈에도 포함되는 경우가 많은데 이는 함수로 이동해야 마땅합니다. 

## 암호 같은 지역변수 이름

일단 변수의 목적을 이해했다면, 다음에 이 코드를 보게 될 여러분과 팀원들을 위해 이름을 변경하는 것이 좋습니다. 

## 과도한 중첩 

단계 깊이의 중첩을 도움 함수로 변경하는 것이 좋습니다. 
조건문이 중첩되어 있으면 보호절 형태로 바꾸어 중첩의 깊이를 낮추는 것이 좋습니다. 

# 레거시 코드 변경 알고리즘 

마이클은 레거시 코드 변경 알고리즘을 아래와 같이 정의한다.

1. 변경점을 식별한다.
2. 테스트 포인트를 찾는다.
3. 의존성을 깨뜨린다.
4. 테스트를 작성한다.
5. 변경하고 리팩터링한다.

## 1. 변경점 식별

첫 단계는 현재 코드에서 변경이 필요하다고 생각하는 부분을 찾아야 합니다. 

## 2. 테스트 포인트 찾기 


변경점이 식별되었으면, 이것을 어떻게 테스트할지 고민해야 합니다. 
해당 코드가 어디서 입력을 받는지, 상황을 감시하기 위한 지점이 어디인지 살펴봐야 합니다. 

## 3. 의존성 깨뜨리기 (혹은 그러지 않기)

레거시 코드를 테스트 하니스에 붙이거나 일부 테스트 포인트에 접근하기 위해서는 의존성을 깨트려야 합니다. 

테스트 대역을 사용하려면 먼저 안전한 함수 추출 리팩터링을 적용할 필요가 있습니다. 
레거시 코드 수정시 이는 좀 더 주의할 필요가 있습니다. 
동료와 함께 작업하는 것이 실수를 방지하는 데에 도움이 될 것입니다. 

전역 데이터에 대한 의존성을 깨트리기 위해서는 문제의 전역 데이터를 접근할 때 접근 함수를 통하도록 캡슐화 할 수 있습니다. 
그런다음 테스트를 하는 동안 접근자를 오버라이드 하는 벙법으로 전역 데이터에 대한 통제권을 확보할 수 있습니다. 

## 4. 테스트 작성 

테스트 포인트를 찾았다면 레거시 코드의 현재 동작을 보존하면서 그 특징이 드러나는 테스트를 작성해야 합니다. 
이는 매우 까다로우며, 특히 테스트 하니스를 처음 연결한다면 더더욱 그럴 것입니다. 
이 부분은 아래 ‘부딪혀가며 통과하기’ 에서 다시 살펴보겠습니다. 

## 5. 변경하고 리팩터링

기존 동작을 보존해주는 테스트가 마련되었으면, 리팩터링을 적용할 수 있는 안전이 확보되었습니다. 
리팩터링을 통해 변경하기 쉽도록 코드를 재구성합니다. 
래거시 동작이 테스트를 통해 안정적으로 유지되면 새로운 동작을 TDD로 작성하기 수월해집니다. 
